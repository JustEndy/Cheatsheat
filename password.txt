#!/bin/bash

DATA_FILE="password_data"
KEY="simplekey123"  # Simple key for XOR-based obfuscation

show_help() {
  echo "Usage: $0 [--secure] <email> <password>"
  echo
  echo "Options:"
  echo "  --help      Show this help message"
  echo "  --secure    Prompt securely for email and password input"
  echo
  echo "Examples:"
  echo "  $0 user@example.com Pa55word!"
  echo "  $0 --secure"
  exit 0
}

# XOR obfuscation (not true crypto, but better than plain text)
encrypt() {
  local input="$1"
  local encrypted=""
  for ((i = 0; i < ${#input}; i++)); do
    local c=${input:$i:1}
    local k=${KEY:$((i % ${#KEY})):1}
    # shellcheck disable=SC2005
    encrypted+=$(printf "%02x" "$(( $(printf '%d' "'$c") ^ $(printf '%d' "'$k") ))")
  done
  echo "$encrypted"
}

# Basic email validation using regex
validate_email() {
  local email_regex="^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"
  [[ "$1" =~ $email_regex ]]
}

# --- Argument handling ---
if [[ "$1" == "--help" ]]; then
  show_help
elif [[ "$1" == "--secure" ]]; then
  read -rp "Enter email: " email
  read -rsp "Enter password: " password
  echo
else
  email="$1"
  password="$2"
fi

# --- Validate input ---
if [[ -z "$email" || -z "$password" ]]; then
  echo "Error: You must provide both an email and password." >&2
  echo "Try '$0 --help' for usage."
  exit 1
fi

if ! validate_email "$email"; then
  echo "Error: Invalid email format." >&2
  exit 1
fi

# --- Encrypt password and save ---
encrypted_pw=$(encrypt "$password")
echo "$email:$encrypted_pw" >> "$DATA_FILE"

echo "Data saved to '$DATA_FILE' (password encrypted)."